#!/usr/bin/env python3
#
# Brainfuck Interpreter
# Copyright 2011 Sebastian Kaspari


import sys
from argparse import ArgumentParser, SUPPRESS
from time import sleep


class _Getch:
    """Read only one character from stdin."""

    def __init__(self):
        try:
            import msvcrt
            self.impl = self.getch_windows
        except ImportError:
            self.impl = self.getch_unix

    def getch_windows(self):
        import msvcrt
        return msvcrt.getch()

    def getch_unix(self):
        import tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            char = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return char

    def __call__(self):
        return self.impl()


def stdout_write(string):
    sys.stdout.write(string)
    sys.stdout.flush()


def _print_cells(cells, ptr=None):
    cells = cells[:]
    if ptr is not None: cells[ptr] = '(%d)' % cells[ptr]
    cells = [str(val).ljust(5) for val in cells]
    stdout_write('\r\033[K')  # Clear line
    stdout_write(' '.join(cells))


def _print_err(err):
    if err == 'USAGE':
        msg = 'usage: brainfuck-py [-h] [-d DELAY] [--dump-tape | ' + \
              '--show-tape] [-i INPUT]\n                    [FILE [FILE ...]]'
    else:
        msg = 'brainfuck: ' + err
    print(msg, file=sys.stderr)
    sys.exit(1)


def _build_bracemap(code):
    temp_bracestack, bracemap = [], {}
    for pos, cmd in enumerate(code):
        if cmd == '[': temp_bracestack.append(pos)
        if cmd == ']':
            start = temp_bracestack.pop()
            bracemap[start] = pos
            bracemap[pos] = start

    return bracemap


def evaluate(code, dump_tape, show_tape, user_in, delay):
    output = ''
    bracemap = _build_bracemap(code)
    cells = [0]
    codeptr, cellptr = 0, 0
    getch = _Getch()

    while codeptr < len(code):
        if show_tape: _print_cells(cells, ptr=cellptr)

        command = code[codeptr]
        if command == '>':
            cellptr += 1
            if cellptr == len(cells): cells.append(0)
        elif command == '<':
            cellptr = 0 if cellptr <= 0 else cellptr - 1
        elif command == '+':
            cells[cellptr] = cells[cellptr] + 1 if cells[cellptr] < 255 else 0
        elif command == '-':
            cells[cellptr] = cells[cellptr] - 1 if cells[cellptr] > 0 else 255
        elif command == '[' and cells[cellptr] == 0:
            codeptr = bracemap[codeptr]
        elif command == ']' and cells[cellptr] != 0:
            codeptr = bracemap[codeptr]
        elif command == '.':
            if dump_tape or show_tape: output += chr(cells[cellptr])
            else: stdout_write(chr(cells[cellptr]))
        elif command == ',':
            if show_tape:
                if len(user_in) == 0:
                    print()
                    _print_err("runtime error: not enough input was given")
                cells[cellptr] = ord(user_in.pop(0))
            else:
                try:
                    cells[cellptr] = ord(getch())
                except:
                    msg = 'runtime error: stdin is already in use.' + \
                          '\nmake sure nothing is being piped in'
                    _print_err(msg)

        codeptr += 1
        sleep(delay/1000.)

    if dump_tape:
        _print_cells(cells)
        print()
    elif show_tape:
        _print_cells(cells, ptr=cellptr)
        print()

    if (dump_tape or show_tape) and output:
        print(output)


def cleanup(code):
    """Remove all non-brainfuck command characters from code."""
    bf_chars = ['>', '<', '+', '-', '[', ']', '.', ',']
    return list(filter(lambda c: c in bf_chars, code))


def main(args):
    read_code = args.code
    print(read_code)
    delay = args.delay
    dump_tape = args.dump_tape
    show_tape = args.show_tape
    user_in = list(args.input)

    if show_tape and user_in == []:  # --show-tape without -i
        _print_err('--show-tape requires -i/--input INPUT')
    if user_in != [] and not show_tape:  # -i without --show-tape
        _print_err('-i/--input is only for use with --show-tape')

    infiles = args.infiles  # Filenames passed as arguments

    if not sys.stdin.isatty():  # stdin is not empty
        if read_code:  # Read Brainfuck code from stdin
            code = cleanup(sys.stdin.read())
            evalueate(code, dump_tape, show_tape, user_in, delay)
        else:  # Read filenames from stdin
            infiles.extend([l.strip() for l in sys.stdin.readlines()])

    if not infiles:
        _print_err('no input given')
    else:
        for fn in infiles:
            try:  # Open and execute Brainfuck script
                with open(fn, 'r') as script:
                    code = cleanup(script.read())
                evaluate(code, dump_tape, show_tape, user_in, delay)
            except FileNotFoundError:
                _print_err('cannot open file ' + fn)


if __name__ == '__main__':
    desc = 'Executes one or more scripts written in brainfuck.'
    h_help = 'Show this help message and exit.'
    file_help = 'One or more names of Brainfuck scripts. Filenames are ' + \
                'read from both the command line and from stdin.'
    c_help = 'Read code rather than filenames from stdin.'
    d_help = 'The delay, in milliseconds, between the execution of each ' + \
             'Brainfuck command.'
    dump_help = 'Output the tape after script execution.'
    show_help = "Show the tape during script execution."
    i_help = "The input for Brainfuck's , command."

    parser = ArgumentParser(description=desc, add_help=False)
    parser.add_argument('-h', '--help', action='help', default=SUPPRESS,
                        help=h_help)
    # nargs must be * so that filenames can be read from stdin
    parser.add_argument('infiles', nargs='*', default=[], metavar='FILE',
                        help=file_help)
    parser.add_argument('-c', '--code', action='store_true', help=c_help)
    parser.add_argument('-d', '--delay', type=int, default=10, help=d_help)
    tape_g = parser.add_mutually_exclusive_group()
    tape_g.add_argument('--dump-tape', action='store_true', help=dump_help)
    tape_g.add_argument('--show-tape', action='store_true', help=show_help)
    parser.add_argument('-i', '--input', default=[], help=i_help)

    main(parser.parse_args())

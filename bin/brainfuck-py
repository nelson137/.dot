#!/usr/bin/env python3
#
# Brainfuck Interpreter
# Copyright 2011 Sebastian Kaspari


import sys
from argparse import ArgumentParser, ArgumentTypeError
from time import sleep


class _GetchUnix:
    def __init__(self):
        import tty

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch


class _GetchWindows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()


class _Getch:
    """Gets a single character from standard input."""
    def __init__(self):
        try:
            self.impl = _GetchWindows()
        except ImportError:
            self.impl = _GetchUnix()

    def __call__(self):
        return self.impl()


def cleanup(code):
    """Remove all non-brainfuck command characters from code."""
    out = filter(lambda x: x in ['>', '<', '+', '-', '[', ']', '.', ','], code)
    return list(out)


def _print_cells(cells, ptr=None):
    cells = cells[:]
    if ptr is not None: cells[ptr] = '(%d)' % cells[ptr]
    cells = [str(val).ljust(5) for val in cells]
    sys.stdout.write('\r\033[K')  # Clear line
    sys.stdout.write(' '.join(cells))
    sys.stdout.flush()


def _build_bracemap(code):
    temp_bracestack, bracemap = [], {}
    for pos, cmd in enumerate(code):
        if cmd == '[': temp_bracestack.append(pos)
        if cmd == ']':
            start = temp_bracestack.pop()
            bracemap[start] = pos
            bracemap[pos] = start

    return bracemap


def evaluate(code, dump_tape, verbose, user_in, delay):
    output = ''
    bracemap = _build_bracemap(code)
    cells = [0]
    codeptr, cellptr = 0, 0
    getch = _Getch()

    while codeptr < len(code):
        if verbose: _print_cells(cells, ptr=cellptr)

        command = code[codeptr]
        if command == '>':
            cellptr += 1
            if cellptr == len(cells): cells.append(0)
        elif command == '<':
            cellptr = 0 if cellptr <= 0 else cellptr - 1
        elif command == '+':
            cells[cellptr] = cells[cellptr] + 1 if cells[cellptr] < 255 else 0
        elif command == '-':
            cells[cellptr] = cells[cellptr] - 1 if cells[cellptr] > 0 else 255
        elif command == '[' and cells[cellptr] == 0:
            codeptr = bracemap[codeptr]
        elif command == ']' and cells[cellptr] != 0:
            codeptr = bracemap[codeptr]
        elif command == '.':
            if dump_tape or verbose: output += chr(cells[cellptr])
            else: sys.stdout.write(chr(cells[cellptr]))
        elif command == ',':
            if verbose: cells[cellptr] = ord(user_in.pop(0))
            else: cells[cellptr] = ord(getch())

        codeptr += 1
        sleep(delay)

    if dump_tape or verbose:
        print(output)

    if dump_tape:
        _print_cells(cells)
        print()
    elif verbose:
        _print_cells(cells, prt=cellptr)
        print()


def _print_err(err):
    if err == 'USAGE':
        msg = 'usage: brainfuck-py [-h] [-d | -t] [-i INPUT] [FILE [FILE ...]]'
    else:
        msg = 'brainfuck error: ' + err
    print(msg, file=sys.stderr)
    sys.exit(1)


def check_delay_type(value):
    print(value)
    try:
        int(value)
    except ValueError:
        raise ArgumentTypeError('%s is not a valid number' % value)


def main(args):
    infiles = args.infiles
    dump_tape = args.dump_tape
    verbose = args.verbose
    user_in = list(args.input)
    delay = float(args.delay)

    if not infiles:  # No file was passed as an argument
        if not sys.stdin.isatty():  # stdin isn't empty
            code = cleanup(sys.stdin.read())
            evaluate(code, dump_tape, verbose, user_in, delay)
        else:  # stdin is empty
            _print_err('USAGE')
            sys.exit(1)
    else:  # At least 1 file was passed as an argument
        for fn in infiles:
            try:
                with open(fn, 'r') as script: code = script.read()
                code = cleanup(code)
                evaluate(code, dump_tape, verbose, user_in, delay)
            except FileNotFoundError:
                _print_err('cannot open file ' + fn)


if __name__ == '__main__':
    desc = 'Executes one or more scripts written in brainfuck.'
    t_help = 'print tape after executing script'
    v_help = 'show tape during script execution'
    i_help = 'input for the , command'
    d_help = 'the delay between each command'

    parser = ArgumentParser(description=desc)
    # nargs must be * so that file can be read from stdin
    parser.add_argument('infiles', nargs='*', metavar='FILE', default=None)
    tape_g = parser.add_mutually_exclusive_group()
    tape_g.add_argument('-t', '--dump-tape', action='store_true', help=d_help)
    tape_g.add_argument('-v', '--verbose', action='store_true', help=t_help)
    parser.add_argument('-i', '--input', default=[], help=i_help)
    parser.add_argument('-d', '--delay', default=.01, type=check_delay_type,
                        help=t_help)

    main(parser.parse_args())

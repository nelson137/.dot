#!/usr/bin/env python3
#
# Brainfuck Interpreter
# Copyright 2011 Sebastian Kaspari


import sys
from argparse import ArgumentParser, Namespace, Action, SUPPRESS
from subprocess import check_output, DEVNULL, CalledProcessError
from time import sleep


class _Getch:
    """Read one character from stdin."""

    def __init__(self):
        try:
            import msvcrt
            self.impl = self.getch_windows
        except ImportError:
            self.impl = self.getch_unix

    def getch_windows(self):
        import msvcrt
        return msvcrt.getch()

    def getch_unix(self):
        import tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            print('Input: ', end='', flush=True)
            char = sys.stdin.read(1)
            print('\r\33[K', end='')
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return char

    def __call__(self):
        return self.impl()


class _DelayAction(Action):
    """Set namespace.delay and namespace.delay_changed."""

    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        super().__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, value, option_string=None):
        setattr(namespace, self.dest, value)
        setattr(namespace, 'delay_changed', True)


def _print_cells(cells, width, ptr=None):
    cells = cells[:]

    # Format cells
    for n in range(len(cells)):
        if ptr is not None and n == ptr:
            cells[n] = '(%s)' % str(cells[n]).ljust(3)
        else:
            cells[n] = ' ' + str(cells[n]).ljust(4)

    # Number of cells per line
    nc = int((width+1)/6)

    # Split cells into lines with a max of nc cells per line
    lines = [' '.join(cells[i:i+nc]) for i in range(0, len(cells), nc)]

    # Output lines
    for l in lines:
        print('\r\33[K', end='')  # Clear line
        print(' ' + l, flush=True)

    # Return number of lines so the cursor can be reset at the top
    return len(lines)


def _err_out(err):
    print('brainfuck:', err, file=sys.stderr)
    sys.exit(1)


def _build_bracemap(code):
    temp_bracestack, bracemap = [], {}
    for pos, cmd in enumerate(code):
        if cmd == '[': temp_bracestack.append(pos)
        if cmd == ']':
            start = temp_bracestack.pop()
            bracemap[start] = pos
            bracemap[pos] = start

    return bracemap


def evaluate(code, width, delay, dump_tape, show_tape, use_input, user_in):
    output = ''
    bracemap = _build_bracemap(code)
    cells = [0]
    codeptr, cellptr = 0, 0
    getch = _Getch()

    while codeptr < len(code):
        if show_tape:
            n_lines = _print_cells(cells, width, ptr=cellptr)

        command = code[codeptr]
        if command == '>':
            cellptr += 1
            if cellptr == len(cells): cells.append(0)
        elif command == '<':
            cellptr = 0 if cellptr <= 0 else cellptr - 1
        elif command == '+':
            cells[cellptr] = cells[cellptr] + 1 if cells[cellptr] < 255 else 0
        elif command == '-':
            cells[cellptr] = cells[cellptr] - 1 if cells[cellptr] > 0 else 255
        elif command == '[' and cells[cellptr] == 0:
            codeptr = bracemap[codeptr]
        elif command == ']' and cells[cellptr] != 0:
            codeptr = bracemap[codeptr]
        elif command == '.':
            if dump_tape or show_tape:
                output += chr(cells[cellptr])
            else:
                print(chr(cells[cellptr]), end='', flush=True)
        elif command == ',':
            if use_input:
                if len(user_in) == 0:
                    _err_out('runtime error: not enough input was given')
                cells[cellptr] = ord(user_in.pop(0))
            else:
                try:
                    cells[cellptr] = ord(getch())
                except:
                    msg = 'runtime error: stdin is already in use.' + \
                          '\nmake sure nothing is being piped in'
                    _err_out(msg)

        if show_tape:
            print('\33[A'*n_lines, end='')

        codeptr += 1
        sleep(delay/1000.)

    if dump_tape:
        _print_cells(cells, width)
    elif show_tape:
        _print_cells(cells, width, ptr=cellptr)

    if (dump_tape or show_tape) and output:
        print(output, end='')


def cleanup(code):
    """Return code with all non-Brainfuck command characters removed."""
    bf_chars = ['>', '<', '+', '-', '[', ']', '.', ',']
    return list(filter(lambda c: c in bf_chars, code))


def get_term_width():
    """Get terminal width, default to 80."""
    try:
        width = int(check_output(['tput', 'cols'], stderr=DEVNULL))
    except CalledProcessError:
        width = 80

    # Subtract 2 for padding
    return width - 2


def main(args):
    stdin_code = args.stdin_code
    stdin_filenames = args.stdin_filenames
    delay = args.delay
    delay_changed = args.delay_changed
    dump_tape = args.dump_tape
    show_tape = args.show_tape

    if args.input is None:
        use_input = False
        user_in = args.input
    else:
        use_input = True
        user_in = list(args.input)

    width = args.width

    # Terminal width is too small for even 1 cell
    if width < 7:
        _err_out('terminal is not wide enough')

    # -i/--input without --show-tape
    if use_input and not show_tape:
        _err_out('-i/--input can only be used with --show-tape')

    # Auto set delay if --show-tape and delay wasn't changed by user
    if show_tape and not delay_changed:
        delay = 125

    infiles = args.infiles  # Filenames passed as arguments
    to_eval = []

    # Read from stdin
    if not sys.stdin.isatty():  # If stdin is not empty
        if stdin_code:
            # Read Brainfuck code
            to_eval.append(cleanup(sys.stdin.read()))
        elif stdin_filenames:
            # Read filenames
            infiles.extend([l.strip() for l in sys.stdin.readlines()])

    # Append code from each Brainfuck script to to_eval
    for fn in infiles:
        try:
            with open(fn, 'r') as script:
                to_eval.append(cleanup(script.read()))
        except FileNotFoundError:
            _err_out('cannot open file ' + fn)

    if not to_eval:
        _err_out('no input given')
    # Evaluate all code
    for code in to_eval:
        evaluate(code, width, delay, dump_tape, show_tape, use_input, user_in)


if __name__ == '__main__':
    desc = 'Executes one or more scripts written in Brainfuck.'
    h_help = 'Show this help message and exit.'
    c_help = 'Read Brainfuck code from stdin.'
    f_help = 'Read Brainfuck script filenames from stdin.'
    d_help = 'The delay, in milliseconds, between the execution of each ' + \
             'Brainfuck command.'
    dump_help = 'Output the tape after script execution.'
    show_help = 'Show the tape during script execution.'
    i_help = "The input for Brainfuck's , command."
    w_help = 'The maximum width for the output.'
    file_help = 'One or more names of Brainfuck scripts. Filenames are ' + \
                'read from both the command line and from stdin.'

    parser = ArgumentParser(description=desc, add_help=False)
    parser.add_argument('-h', '--help', action='help', default=SUPPRESS,
                        help=h_help)
    stdin_type = parser.add_mutually_exclusive_group()
    stdin_type.add_argument('-c', '--stdin-code', action='store_true',
                            help=c_help)
    stdin_type.add_argument('-f', '--stdin-filenames', action='store_true',
                            help=f_help)
    # Use _DelayAction to set delay and delay_changed when -d/--delay is used
    parser.add_argument('-d', '--delay', action=_DelayAction, type=int,
                        default=0, help=d_help)
    tape_g = parser.add_mutually_exclusive_group()
    tape_g.add_argument('--dump-tape', action='store_true', help=dump_help)
    tape_g.add_argument('--show-tape', action='store_true', help=show_help)
    parser.add_argument('-i', '--input', help=i_help)
    parser.add_argument('-w', '--width', type=int, default=get_term_width(),
                        help=w_help)
    # nargs='*' so that filenames or code can be read from stdin
    parser.add_argument('infiles', nargs='*', default=[], metavar='FILE',
                        help=file_help)

    # Set delay_changed to False by default
    ns = Namespace(delay_changed=False)
    main(parser.parse_args(namespace=ns))

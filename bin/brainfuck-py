#!/usr/bin/env python3

"""Interpret Brainfuck programs.

Copyright 2011 Sebastian Kaspari
"""


import sys
from argparse import ArgumentParser, Namespace, Action, SUPPRESS
from subprocess import check_output, DEVNULL, CalledProcessError
from time import sleep


class DelayAction(Action):
    """Set namespace.delay and namespace.delay_changed."""

    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        super().__init__(option_strings, dest, **kwargs)

    def __call__(self, _, namespace, value, option_string=None):
        setattr(namespace, self.dest, value)
        setattr(namespace, 'delay_changed', True)


def err_out(err):
    """Output err to stderr and exit with an error code of 1."""
    print('brainfuck-py:', err, file=sys.stderr)
    sys.exit(1)


def getch():
    """Read one character from stdin."""
    print('Input: ', end='', flush=True)
    try:
        import msvcrt
        char = msvcrt.getch()
    except ImportError:
        import tty
        from termios import error, tcgetattr, tcsetattr, TCSADRAIN
        fd = sys.stdin.fileno()
        old_settings = tcgetattr(fd)
        try:
            tty.setraw(fd)
            print('Input: ', end='', flush=True)
            char = sys.stdin.read(1)
            print('\r\33[K', end='')
        except error:
            char = None
        finally:
            tcsetattr(fd, TCSADRAIN, old_settings)
    print('\r\33[K', end='')
    return char


def print_cells(cells, width, ptr=None):
    cells = cells[:]

    # Format cells
    for i, value in enumerate(cells):
        format_str = '(%s)' if ptr is not None and i == ptr else ' %s '
        cells[i] = format_str % str(value).ljust(3)

    # Number of cells per line
    nc = int((width+1)/6)

    # Split cells into lines with a max of nc cells per line
    lines = [' '.join(cells[i:i+nc]) for i in range(0, len(cells), nc)]

    # Output lines
    for l in lines:
        print('\r\33[K', end='')  # Clear line
        print(' ' + l, flush=True)

    # Return number of lines so the cursor can be reset at the top
    return len(lines)


def build_bracemap(code):
    """Return a dict ."""
    temp_bracestack, bracemap = [], {}
    for pos, cmd in enumerate(code):
        if cmd == '[':
            temp_bracestack.append(pos)
        if cmd == ']':
            start = temp_bracestack.pop()
            bracemap[start] = pos
            bracemap[pos] = start

    return bracemap


def evaluate(code, width, delay, dump_tape, show_tape, use_input, user_in):
    """Interpret the Brainfuck code.

    Interprets the Brainfuck code, character by character, pausing for delay
    milliseconds after each command is processed. If the user requested the
    tape be shown live, while the program is being executed, the output is not
    printed until after the program has terminated. Otherwise, the output is
    printed out as the program is being interpreted.

    Args:
        code: A list of Brainfuck-only characters to be executed.
        width: The width of the terminal.
        delay: The delay between each Brainfuck character's execution.
        dump_tape: Whether or not the tape should be shown after execution.
        show_tape: Whether or not the tape should be shown during execution.
        use_input: Whether or not the
        user_in: A string of input to be passed to the Brainfuck program.

    Returns:
        Nothing.
    """
    output = ''
    bracemap = build_bracemap(code)
    cells = [0]
    codeptr, cellptr = 0, 0

    while codeptr < len(code):
        if show_tape:
            n_lines = print_cells(cells, width, ptr=cellptr)

        command = code[codeptr]
        if command == '>':
            cellptr += 1
            if cellptr == len(cells):
                cells.append(0)
        elif command == '<':
            cellptr = 0 if cellptr <= 0 else cellptr - 1
        elif command == '+':
            cells[cellptr] = cells[cellptr] + 1 if cells[cellptr] < 255 else 0
        elif command == '-':
            cells[cellptr] = cells[cellptr] - 1 if cells[cellptr] > 0 else 255
        elif command == '[' and cells[cellptr] == 0:
            codeptr = bracemap[codeptr]
        elif command == ']' and cells[cellptr] != 0:
            codeptr = bracemap[codeptr]
        elif command == '.':
            if dump_tape or show_tape:
                output += chr(cells[cellptr])
            else:
                print(chr(cells[cellptr]), end='', flush=True)
        elif command == ',':
            if use_input:
                if not user_in:
                    err_out('runtime error: not enough input was given')
                cells[cellptr] = ord(user_in.pop(0))
            else:
                char = getch()
                if char is None:
                    msg = 'runtime error: stdin is already in use.' + \
                          '\nmake sure nothing is being piped in'
                    err_out(msg)
                else:
                    cells[cellptr] = ord(char)

        if show_tape:
            print('\33[A'*n_lines, end='')

        codeptr += 1
        sleep(delay/1000.)

    if dump_tape:
        print_cells(cells, width)
    elif show_tape:
        print_cells(cells, width, ptr=cellptr)

    if (dump_tape or show_tape) and output:
        print(output, end='')


def cleanup(code):
    """Return code with all non-Brainfuck command characters removed."""
    bf_chars = ['>', '<', '+', '-', '[', ']', '.', ',']
    return [c for c in code if c in bf_chars]


def get_term_width():
    """Get terminal width, default to 80."""
    try:
        width = int(check_output(['tput', 'cols'], stderr=DEVNULL))
    except CalledProcessError:
        width = 80

    # Subtract 2 for padding
    return width - 2


def main(args):
    """Do some error checking, then interpret all Brainfuck code."""
    stdin_code = args.stdin_code
    stdin_filenames = args.stdin_filenames
    delay = args.delay
    delay_changed = args.delay_changed
    dump_tape = args.dump_tape
    show_tape = args.show_tape

    if args.input is None:
        use_input = False
        user_in = args.input
    else:
        use_input = True
        user_in = list(args.input)

    width = args.width

    # Terminal width is too small for even 1 cell
    if width < 7:
        err_out('terminal is not wide enough')

    # -i/--input without --show-tape
    if use_input and not show_tape:
        err_out('-i/--input can only be used with --show-tape')

    # Auto set delay if --show-tape and delay wasn't changed by user
    if show_tape and not delay_changed:
        delay = 125

    infiles = args.infiles  # Filenames passed as arguments
    to_eval = []

    # Read from stdin
    if not sys.stdin.isatty():  # If stdin is not empty
        if stdin_code:
            # Read Brainfuck code
            to_eval.append(cleanup(sys.stdin.read()))
        elif stdin_filenames:
            # Read filenames
            infiles.extend([l.strip() for l in sys.stdin.readlines()])

    # Append code from each Brainfuck script to to_eval
    for fn in infiles:
        try:
            with open(fn, 'r') as script:
                to_eval.append(cleanup(script.read()))
        except FileNotFoundError:
            err_out('cannot open file ' + fn)

    if not to_eval:
        err_out('no input given')
    # Evaluate all code
    for code in to_eval:
        evaluate(code, width, delay, dump_tape, show_tape, use_input, user_in)


if __name__ == '__main__':
    desc = 'Executes one or more scripts written in Brainfuck.'
    h_help = 'Show this help message and exit.'
    c_help = 'Read Brainfuck code from stdin.'
    f_help = 'Read Brainfuck script filenames from stdin.'
    d_help = 'The delay, in milliseconds, between the execution of each ' + \
             'Brainfuck command.'
    dump_help = 'Output the tape after script execution.'
    show_help = 'Show the tape during script execution.'
    i_help = "The input for Brainfuck's , command."
    w_help = 'The maximum width for the output.'
    file_help = 'One or more names of Brainfuck scripts. Filenames are ' + \
                'read from both the command line and from stdin.'

    parser = ArgumentParser(description=desc, add_help=False)
    parser.add_argument('-h', '--help', action='help', default=SUPPRESS,
                        help=h_help)
    stdin_type = parser.add_mutually_exclusive_group()
    stdin_type.add_argument('-c', '--stdin-code', action='store_true',
                            help=c_help)
    stdin_type.add_argument('-f', '--stdin-filenames', action='store_true',
                            help=f_help)
    # Use DelayAction to set delay and delay_changed when -d/--delay is used
    parser.add_argument('-d', '--delay', action=DelayAction, type=int,
                        default=0, help=d_help)
    tape_g = parser.add_mutually_exclusive_group()
    tape_g.add_argument('--dump-tape', action='store_true', help=dump_help)
    tape_g.add_argument('--show-tape', action='store_true', help=show_help)
    parser.add_argument('-i', '--input', help=i_help)
    parser.add_argument('-w', '--width', type=int, default=get_term_width(),
                        help=w_help)
    # nargs='*' so that filenames or code can be read from stdin
    parser.add_argument('infiles', nargs='*', default=[], metavar='FILE',
                        help=file_help)

    # Set delay_changed to False by default
    ns = Namespace(delay_changed=False)
    main(parser.parse_args(namespace=ns))
